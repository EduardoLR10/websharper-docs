# Build a reactive user interface with UI.Next

WebSharper level: newcomer
F# level: intermediate

This tutorial will take you through the steps to create a fully reactive client-side user interface using UI.Next. We will create a simple Kanban board like the following:

![Screenshot](...) (or maybe tryws link? this is a modified version of http://try.websharper.com/snippet/loic.denuziere/0000Do)

## Creating the project

First, let's create the project. Since this is going to be a client-only project (for now), we'll create a Single-Page Application.

### Visual Studio

### (others?)

### Exploring and initializing the project

Right now, our new project contains a sample mini application that shows a simple list of names. You can compile it and run it (Ctrl+F5) to see what this looks like; but we're going to clear it to put our Kanban board instead.

There are two main files of interest in this project:

* `Client.fs` contains the main F# sources for the application. Let's remove the contents of the `module Client` and replace them with the following:

    ```fsharp
    [<SPAEntryPoint>]
    let Main () =
        ()
    ```
    
    This is just a function which does nothing. The attribute `[<SPAEntryPoint>]` tells WebSharper that this is the function that it must run on startup, ie. when the web page is loaded.

* `index.html` is the HTML page in which we will design the application. We can remove the contents of the `<body>` tag, except for the final `<script>` tag: this one points to `Content/Kanban.min.js`, which is the JavaScript generated by WebSharper, so we definitely want to keep it!

## Creating a simple form

Let's dip our toes into reactive UI by writing the form that creates a new card. We want the following controls:

* A text input for the card's text;
* A dropdown selector for the card's color;
* A button to confirm and add the card.

### Writing HTML in F# ###

In UI.Next, fragments of HTML code are represented by the **`Doc`** type. Such a fragment can be composed of zero, one or several consecutive elements or text nodes.

UI.Next includes functions to easily write HTML tags and attributes in F#. For this, we'll need to add a line at the end of our file's `open`s:

```fsharp
open WebSharper.UI.Next.Html
```

This gives us functions to create HTML elements. They are named simply after the element, and take a list of children as argument. Additionally, the `text` function creates a simple text node. For example:

```fsharp
let thisTutorial =
    div [
        h1 [ text "Build a reactive user interface with UI.Next" ]
        p [ text "This tutorial will take you through the steps to create..." ]
    ]
```

Here, we want a form with an input, a dropdown and a button, so let's start by adding the following above the `Main` function:

```fsharp
    let addCardForm =
        form [
            input []
            select []
            button [ text "Add" ]
        ]
```

You might notice that `addCardForm` actually has type **`Elt`**, rather than **`Doc`**. `Elt` is a subtype of `Doc` which is guaranteed to consist of exactly one element, and has methods that operate on this element, like `AppendChild` or `GetAttribute`.

To add attributes to an element, say a `div`, we need to use the function `divAttr`, which takes an additional list of attributes. These attributes are defined as methods on the `attr` class. Let's add a placeholder to our input box, options to our selector, and an id to our form:

```fsharp
    let addCardForm =
        formAttr [ attr.id "add-form" ] [
            inputAttr [ attr.placeholder "Add a new card" ] []
            select [
                optionAttr [ attr.value "orangered" ] [ text "Red" ]
                optionAttr [ attr.value "yellow" ] [ text "Yellow" ]
                optionAttr [ attr.value "skyblue" ] [ text "Blue" ]
                optionAttr [ attr.value "lightgreen" ] [text "Green" ]
            ]
            button [ text "Add" ]
        ]
```

Now we just need to insert this into the document in the `Main` function. This is done using the `Doc.Run*` family of functions. In this case we want to add our form at the end of the body, so we use `Doc.RunAppend`:

```fsharp
    [<SPAEntryPoint>]
    let Main () =
        Doc.RunAppend JS.Document.Body addCardForm
```

### Reactive variables: `Var`

This is all nice, but if we're only going to write HTML, we could just have done so in `index.html`. The reason for managing our markup within UI.Next is that we can now make it reactive.

So let's introduce the first type for reactive programming in UI.Next: **`Var<'T>`**. A Var is a mutable cell, in some ways similar to a `ref<'T>`. But its power resides in the fact that it can be reactively observed: whenever its value changes, this change is automatically propagated to any value that is defined as depending on it.

Creating a `Var` is easy, just use the function `Var.Create` with the initial value:

```fsharp
let varText = Var.Create ""
```

You can then get or set its value using the `Value` property:

```fsharp
varText.Value <- "something!"
// VarText is something!
printfn "VarText is %s" varText.Value
```

### Binding Vars with elements

UI.Next can create elements reactively bound to a Var: whenever the user interacts with this element, the Var is set accordingly, and conversely, when the Var's value changes, the element is updated.

The first such element we'll see is `Doc.Input`. It takes a list of attributes and a Var of string, and returns an `<input>` element bound to this var. Let's replace the `inputAttr` of our form with the following:

```fsharp
Doc.Input [ attr.placeholder "Add a new card" ] varText
```

The select box is a bit more complex, but it is pretty powerful. Instead of providing a list of `<option>` tags with string values, it can handle strongly typed values. Let's take advantage of this by defining a type for our colors:

```fsharp
type Color =
    | Red
    | Yellow
    | Green
    | Blue
    
    member this.Css =
        match this with
        | Red -> "orangered"
        | Yellow -> "yellow"
        | Green -> "lightgreen"
        | Blue -> "skyblue"
        
    member this.Name = sprintf "%A" this
    
    static member All = [ Red; Yellow; Green; Blue ]
```

Now, for the `<select>` element itself. In addition to a list of attributes and a Var, like `Doc.Input`, `Doc.Select` needs two extra arguments: the list of option values, and how to display each of them.

```fsharp
Doc.Select [] (fun (x: Color) -> x.Name) Color.All varColor
```

<!-- TODO: screenshot -->

### 

### Event handlers

## Using HTML templates

## Data storage: using ListModel

<a name="css"></a>
## Appendix: style sheet

Here is the CSS style sheet for our application:

```css
/* TODO */
```
